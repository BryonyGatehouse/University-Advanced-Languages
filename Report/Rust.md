# Report : Rust

When creating a regex engine in ruby, I was able to use my knowledge of Java classes to create a tree-like structure made of Nodes (pipe, parentheses, asterisk) and Leaves (literal, dot). As F# is a functional language, this method became less focused on the classes and more focused on the methods. The tree structure was able to survive and became types with specific methods. Finally, in Rust, the types became titles for identifying patterns, with no methods attached. However, these methods were important so, to continue to use these methods, they had to be passed any expression pattern, before checking its type as enum-types couldn’t be declared as the parameter type.

The Vector is a structure which keeps its elements in an ordered list, which is used to represent the expression. This is used in the Parentheses pattern, to hold the inner expression, and in the Pipe pattern as a Vector of Vectors of Patterns, or to hold all possible expressions separately. It can have a dynamic size and provides many methods including `.len()` to get the amount of elements, `[index]` to get an element, and `.remove(index)` to remove and return an element.

The String structure is a dynamic string, allowing modification, ownership, and more access to the characters compared to the immutable sequence type str. This is used for the target string.

Rust sets the ownership of each variable very carefully, reducing its lifetime and thus cluttered space in the memory. Unfortunately, this proved annoying in this project, as it wasn’t large enough to worry about memory problems. Instead, it resulted in many minor problems, particularly during while loops where items were retrieved from Vectors, as the Vector’s location was seen as passed during the first loop, thus preventing its use in the next loop. Some loops could use clones of an object, cloned each loop. However, this method didn’t work for the most important loop: iterating through the expression patterns. Instead, the Vector had to be copied before the loop, then the first item removed each loop.

When reading a file, Rust provides a few methods including retrieving all the lines as a collection or reading them one by one. Since this project required reading two files at the same time, reading each line in separately was a better method. However, the line included the newline character at the end, which produced confusing results when first tested. The method `pop()` for strings removes the last character from a string, perfect for removing that newline character. Though it must be mentioned that the last line may not contain a newline character, so it should be checked that it is there before removing to prevent losing important information.

Global variables produced errors when trying to update them: this method was used in the last two projects to keep the string index global. Instead, Rust offered a tuple structure which allows multiple objects to be returned from a function. This meant that the index could be passed into the method, then returned in its updated form, alongside the boolean indicating the correctness of the pattern and target.

A different method to compare targets and expressions using Rust might be to work backwards, along both the expression and the target. This would work more effectively with the lack of classes and the ownership rules of Rust. This could also remove the need for a tree structure of patterns if it weren’t for the Pipe pattern. Every other pattern can be recognised when travelling backwards, but not the Pipe. Thus, the pipe could be parsed into a structure, separating the two sides. The two sides could then be checked against the target with no worry.

A more computation consuming method is to attempt all possible combinations of the patterns. A pattern of `a*` could match anything, including an empty string. Instead of searching for the next literal in the expression, each possible number of a’s could be tested until either the correct one is found, or it is proven that the target string doesn’t match the expression. However, this sort of method would require many loops which have been proven to be difficult in Rust, due to its ownership rules.

To keep a similar method of comparison, I chose to translate the F# program into Rust. This is because they share more similarities than Rust and Ruby, as Ruby uses classes to hold information while Rust and F# hold information in structs or enums. However, as F# is a functional language, functions can be passed as parameters, meaning an object’s variables could include functions. In Rust, structs are like Ruby classes, but don’t allow inheritance. A node in the tree structure can have any type of node or leaf as its children, thus requiring some form of inheritance. However, an enum, which does support inheritance by declaring a type then variants of the type, doesn’t support a type having unique functions. The conclusion was to use an enum to represent the nodes and leaves of the tree structure, as functions could be created elsewhere. An example of a function for a particular type is the `check()` function which must accept any type of Expr but immediately checks if the given object is of variant `Lit(inner)`, returning false if a different type has been passed. The method must accept an Expr type as variants aren’t recognised as a type.

In the F# program, the list of patterns was filtered to only include the `.*` pattern. Because each object was unique, their index could be found in the original list. However, this method was difficult to replicate in Rust, leading me to a much more effective result. As the objects would have been copied anyway, so finding it in the original list would be impossible, the `collect_star_dot()` method creates a list of all indexes in the list where a `.*` pattern happens. This removes the need to search through the list each time to find an object which matches the current object.
